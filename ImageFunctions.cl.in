
//
// The .in version of this file contains symbols of the
// form <percent><openparen><symbol><closepren><type>) where <symbole> is the name
// of a symbol to be replaced and the data type is specified by printf conventions
//

// Image size
#define SLICES %(slices)d
#define ROWS %(rows)d
#define COLUMNS %(columns)d

// Oriented image spacing
//#define XSPACING %(xspacing)f
//#define YSPACING %(yspacing)f
//#define ZSPACING %(zspacing)f

// TODO image origin spacing and orientation
// How to store orientation matrix? pass it through device array? or pass it
// through #def constants? more recompilations? is this OK?

//#define GAUSSIAN_KERNEL_SIZE %(kernelSize)d
//#define GAUSSIAN_KERNEL_WIDTH %(kernelWidth)f

#define NUM_GAUSSIAN_STEPS 4

//
// Basic data management
//

__kernel void copy(__global float* src, __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  dst[offset] = src[offset];
}

__kernel void zero(__global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  dst[offset] = 0.0;
}

//
// Basic arithmetic kernels
//

// TODO NOT NEEDED, just do a_array + b_array
__kernel void add(
  __global float* src1, __global float* src2, __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  dst[offset] = src1[offset] + src2[offset];
}

__kernel void add_scalar(
  __global float* src, __global float* shift, __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  dst[offset] = src[offset] + shift[0];
}

__kernel void subtract(
  __global float* src1, __global float* src2, __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  dst[offset] = src1[offset] - src2[offset];
}

__kernel void subtract_scalar(
  __global float* src, __global float* shift, __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  dst[offset] = src[offset] - shift[0];
}

__kernel void multiply(
  __global float* src1, __global float* src2, __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  dst[offset] = src1[offset] * src2[offset];
}

__kernel void multiply_scalar(
  __global float* src, __global float* scale, __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  dst[offset] = src[offset] * scale[0];
}

//
// Gaussian filtering
//

// Use float array to store var and width due to PyOpenCL issue (???)
__kernel void gaussian_x(
  __global float* src,
  __global float* var, __global int* width,
  __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  size_t kernelSize = convert_uint(width[0]);
  size_t halfKernelSize = kernelSize / 2;

  float kernelWidthSq = var[0];

  size_t slice0 = slice - halfKernelSize;
  if (slice0 >= SLICES) slice0 = 0;

  size_t slice1 = slice + halfKernelSize;
  if (slice1 >= SLICES) slice1 = SLICES - 1;

  float fslice = convert_float(slice);

  float wv = 0.0;
  float n_weight = 0.0;

  for (size_t pslice = slice0; pslice <= slice1; pslice++)
  {
    float d = convert_float(pslice) - fslice;
    float g = exp(-0.5 * d*d / kernelWidthSq);

    size_t n_offset = pslice*ROWS*COLUMNS + row*COLUMNS + column;
    wv += src[n_offset] * g;

    n_weight += g;
  }

  if (n_weight > 0.0)
    wv /= n_weight;

  dst[offset] = wv;
}

__kernel void gaussian_y(
  __global float* src,
  __global float* var, __global int* width,
  __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  size_t kernelSize = convert_uint(width[0]);
  size_t halfKernelSize = kernelSize / 2;

  float kernelWidthSq = var[0];

  size_t row0 = row - halfKernelSize;
  if (row0 >= ROWS) row0 = 0;

  size_t row1 = row + halfKernelSize;
  if (row1 >= ROWS) row1 = ROWS - 1;

  float frow = convert_float(row);

  float wv = 0.0;
  float n_weight = 0.0;

  for (size_t prow = row0; prow <= row1; prow++)
  {
    float d = convert_float(prow) - frow;
    float g = exp(-0.5 * d*d / kernelWidthSq);

    size_t n_offset = slice*ROWS*COLUMNS + prow*COLUMNS + column;
    wv += src[n_offset] * g;

    n_weight += g;
  }

  if (n_weight > 0.0)
    wv /= n_weight;

  dst[offset] = wv;
}

__kernel void gaussian_z(
  __global float* src,
  __global float* var, __global int* width,
  __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  size_t kernelSize = convert_uint(width[0]);
  size_t halfKernelSize = kernelSize / 2;

  float kernelWidthSq = var[0];

  size_t column0 = column - halfKernelSize;
  if (column0 >= COLUMNS) column0 = 0;

  size_t column1 = column + halfKernelSize;
  if (column1 >= COLUMNS) column1 = COLUMNS - 1;

  float fcolumn = convert_float(column);

  float wv = 0.0;
  float n_weight = 0.0;

  for (size_t pcolumn = column0; pcolumn <= column1; pcolumn++)
  {
    float d = convert_float(pcolumn) - fcolumn;
    float g = exp(-0.5 * d*d / kernelWidthSq);

    size_t n_offset = slice*ROWS*COLUMNS + row*COLUMNS + pcolumn;
    wv += src[n_offset] * g;

    n_weight += g;
  }

  if (n_weight > 0.0)
    wv /= n_weight;

  dst[offset] = wv;
}

// Gaussian filtering in x direction, in-place
__kernel void recursive_gaussian_x(
  __global float* img,
  __global uint* size,
  __global float* sigma)
{
  size_t column = get_global_id(1);
  size_t row = get_global_id(0);

  if (row >= ROWS || column >= COLUMNS)
    return;

  size_t sliceStart = row*COLUMNS + column;
  size_t sliceEnd = (SLICES-1)*ROWS*COLUMNS + row*COLUMNS + column;

  // TODO
  //float ssigma = sigma[0] / spacing[0];

  float lambda = (sigma[0]*sigma[0]) / (2.0 * convert_float(NUM_GAUSSIAN_STEPS));
  float nu = (1.0 + 2.0*lambda - sqrt(1.0 + 4.0*lambda)) / (2.0*lambda);

  float boundary = (1.0 / (1.0 - nu));

  for (int step = 0; step < NUM_GAUSSIAN_STEPS; step++)
  {
    img[sliceStart] *= boundary;

    for (size_t slice = 1; slice < SLICES; slice++)
    {
      size_t pos = slice*ROWS*COLUMNS + sliceStart;
      size_t pos_prev = (slice-1)*ROWS*COLUMNS + sliceStart;
      //barrier(CLK_GLOBAL_MEM_FENCE);
      img[pos] += img[pos_prev] * nu;
    }

    img[sliceEnd] *= boundary;

    for (size_t slice = (SLICES-1); slice > 0; slice--)
    {
      size_t pos = slice*ROWS*COLUMNS + sliceStart;
      size_t pos_prev = (slice-1)*ROWS*COLUMNS + sliceStart;
      //barrier(CLK_GLOBAL_MEM_FENCE);
      img[pos_prev] += img[pos] * nu;
    }
  }

  for (size_t slice = 0; slice < SLICES; slice++)
  {
    size_t pos = slice*ROWS*COLUMNS + sliceStart;
    img[pos] *= pow(nu / lambda, convert_float(NUM_GAUSSIAN_STEPS));
  }
}

// Gaussian filtering in y direction, in-place
__kernel void recursive_gaussian_y(
  __global float* img,
  __global float* sigma)
{
  size_t column = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || column >= COLUMNS)
    return;

  // TODO
  //float ssigma = sigma[0] / spacing[1];

  size_t rowStart = slice*ROWS*COLUMNS + column;
  size_t rowEnd = slice*ROWS*COLUMNS + (ROWS-1)*COLUMNS + column;

  float lambda = (sigma[0]*sigma[0]) / (2.0 * convert_float(NUM_GAUSSIAN_STEPS));
  float nu = (1.0 + 2.0*lambda - sqrt(1.0 + 4.0*lambda)) / (2.0*lambda);

  float boundary = (1.0 / (1.0 - nu));

  for (int step = 0; step < NUM_GAUSSIAN_STEPS; step++)
  {
    img[rowStart] *= boundary;

    for (size_t row = 1; row < ROWS; row++)
    {
      size_t pos = row*COLUMNS + rowStart;
      size_t pos_prev = (row-1)*COLUMNS + rowStart;
      //barrier(CLK_GLOBAL_MEM_FENCE);
      img[pos] += img[pos_prev] * nu;
    }

    img[rowEnd] *= boundary;

    for (size_t row = (ROWS-1); row > 0; row--)
    {
      size_t pos = row*COLUMNS + rowStart;
      size_t pos_prev = (row-1)*COLUMNS + rowStart;
      //barrier(CLK_GLOBAL_MEM_FENCE);
      img[pos_prev] += img[pos] * nu;
    }
  }

  for (size_t row = 0; row < ROWS; row++)
  {
    size_t pos = row*COLUMNS + rowStart;
    img[pos] *= pow(nu / lambda, convert_float(NUM_GAUSSIAN_STEPS));
  }
}

// Gaussian filtering in z direction, in-place
__kernel void recursive_gaussian_z(
  __global float* img,
  __global float* sigma)
{
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS)
    return;

  // TODO
  //float ssigma = sigma[0] / spacing[2];

  size_t columnStart = slice*ROWS*COLUMNS + row*COLUMNS;
  size_t columnEnd = slice*ROWS*COLUMNS + row*COLUMNS + COLUMNS-1;

  float lambda = (sigma[0]*sigma[0]) / (2.0 * convert_float(NUM_GAUSSIAN_STEPS));
  float nu = (1.0 + 2.0*lambda - sqrt(1.0 + 4.0*lambda)) / (2.0*lambda);

  float boundary = (1.0 / (1.0 - nu));

  for (int step = 0; step < NUM_GAUSSIAN_STEPS; step++)
  {
    img[columnStart] *= boundary;

    for (size_t column = 1; column < COLUMNS; column++)
    {
      size_t pos = column + columnStart;
      size_t pos_prev = (column-1) + columnStart;
      //barrier(CLK_GLOBAL_MEM_FENCE);
      img[pos] += img[pos_prev] * nu;
    }

    img[columnEnd] *= boundary;

    for (size_t column = (COLUMNS-1); column > 0; column--)
    {
      size_t pos = column + columnStart;
      size_t pos_prev = (column-1) + columnStart;
      //barrier(CLK_GLOBAL_MEM_FENCE);
      img[pos_prev] += img[pos] * nu;
    }
  }

  for (size_t column = 0; column < COLUMNS; column++)
  {
    size_t pos = column + columnStart;
    img[pos] *= pow(nu / lambda, convert_float(NUM_GAUSSIAN_STEPS));
  }
}

//
// Gradient using central finite difference
//

__kernel void gradient(
  __global float* src,
  __global float* dst_x,
  __global float* dst_y,
  __global float* dst_z)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t slice_a = slice - 1;
  size_t slice_b = slice + 1;
  size_t row_a = row - 1;
  size_t row_b = row + 1;
  size_t column_a = column - 1;
  size_t column_b = column + 1;

  if (slice_a >= SLICES) slice_a = 0;
  if (slice_b >= SLICES) slice_b = SLICES - 1;
  if (row_a >= ROWS) row_a = 0;
  if (row_b >= ROWS) row_b = ROWS - 1;
  if (column_a >= COLUMNS) column_a = 0;
  if (column_b >= COLUMNS) column_b = COLUMNS - 1;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  size_t offset_a_x = slice_a*ROWS*COLUMNS + row*COLUMNS + column;
  size_t offset_b_x = slice_b*ROWS*COLUMNS + row*COLUMNS + column;
  size_t offset_a_y = slice*ROWS*COLUMNS + row_a*COLUMNS + column;
  size_t offset_b_y = slice*ROWS*COLUMNS + row_b*COLUMNS + column;
  size_t offset_a_z = slice*ROWS*COLUMNS + row*COLUMNS + column_a;
  size_t offset_b_z = slice*ROWS*COLUMNS + row*COLUMNS + column_b;

// TODO divide by oriented spacing

  dst_x[offset] = 0.5*(src[offset_b_x] - src[offset_a_x]);
  dst_y[offset] = 0.5*(src[offset_b_y] - src[offset_a_y]);
  dst_z[offset] = 0.5*(src[offset_b_z] - src[offset_a_z]);
}

//
// Interpolation
//

__kernel void interpolate(
  __global float* src,
  __global float* spacing,
  __global float* hx,
  __global float* hy,
  __global float* hz,
  __global float* dst)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  // TODO Convert to voxel coordinate
// TODO use origin and oriented spacing , from orientMat * spacing?
// TODO make sure all inputs are converted to axial orient with non-neg spacings beforehand

  float x = hx[offset] / spacing[0];
  float y = hy[offset] / spacing[1];
  float z = hz[offset] / spacing[2];

  int x0 = convert_int(x);
  int y0 = convert_int(y);
  int z0 = convert_int(z);

  if (x0 < 0) x0 = 0;
  if (y0 < 0) y0 = 0;
  if (z0 < 0) z0 = 0;
  if (x0 > (SLICES-1)) x0 = SLICES-1;
  if (y0 > (ROWS-1)) y0 = ROWS-1;
  if (z0 > (COLUMNS-1)) z0 = COLUMNS-1;

  int x1 = x0 + 1;
  int y1 = y0 + 1;
  int z1 = z0 + 1;

  if (x1 < 0) x1 = 0;
  if (y1 < 0) y1 = 0;
  if (z1 < 0) z1 = 0;
  if (x1 > (SLICES-1)) x1 = SLICES-1;
  if (y1 > (ROWS-1)) y1 = ROWS-1;
  if (z1 > (COLUMNS-1)) z1 = COLUMNS-1;

  float fx1 = x - floor(x);
  float fy1 = y - floor(y);
  float fz1 = z - floor(z);

  float fx0 = 1.0 - fx1;
  float fy0 = 1.0 - fy1;
  float fz0 = 1.0 - fz1;

  float pix000 = src[x0*ROWS*COLUMNS + y0*COLUMNS + z0];
  float pix001 = src[x0*ROWS*COLUMNS + y0*COLUMNS + z1];
  float pix010 = src[x0*ROWS*COLUMNS + y1*COLUMNS + z0];
  float pix011 = src[x0*ROWS*COLUMNS + y1*COLUMNS + z1];
  float pix100 = src[x1*ROWS*COLUMNS + y0*COLUMNS + z0];
  float pix101 = src[x1*ROWS*COLUMNS + y0*COLUMNS + z1];
  float pix110 = src[x1*ROWS*COLUMNS + y1*COLUMNS + z0];
  float pix111 = src[x1*ROWS*COLUMNS + y1*COLUMNS + z1];

  dst[offset] =
    fx0*fy0*fz0*pix000
    + fx0*fy0*fz1*pix001
    + fx0*fy1*fz0*pix010
    + fx0*fy1*fz1*pix011
    + fx1*fy0*fz0*pix100
    + fx1*fy0*fz1*pix101
    + fx1*fy1*fz0*pix110
    + fx1*fy1*fz1*pix111;
}

__kernel void interpolate_s(
  __global float* src,
  __global int* insize,
  __global float* inspacing,
  __global float* hx,
  __global float* hy,
  __global float* hz,
  __global float* dst,
  __global int* outsize)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= outsize[0] || row >= outsize[1] || column >= outsize[2])
    return;

  size_t offset = slice*outsize[1]*outsize[2] + row*outsize[2] + column;

  // TODO Convert to voxel coordinate
// TODO use origin and oriented spacing , from orientMat * spacing?
// TODO make sure all inputs are converted to axial orient with non-neg spacings beforehand

  float x = hx[offset] / inspacing[0];
  float y = hy[offset] / inspacing[1];
  float z = hz[offset] / inspacing[2];

  int x0 = convert_int(x);
  int y0 = convert_int(y);
  int z0 = convert_int(z);

  if (x0 < 0) x0 = 0;
  if (y0 < 0) y0 = 0;
  if (z0 < 0) z0 = 0;
  if (x0 >= insize[0]) x0 = insize[0]-1;
  if (y0 >= insize[0]) y0 = insize[1]-1;
  if (z0 >= insize[0]) z0 = insize[2]-1;

  int x1 = x0 + 1;
  int y1 = y0 + 1;
  int z1 = z0 + 1;

  if (x1 < 0) x1 = 0;
  if (y1 < 0) y1 = 0;
  if (z1 < 0) z1 = 0;
  if (x1 >= insize[0]) x1 = insize[0]-1;
  if (y1 >= insize[0]) y1 = insize[1]-1;
  if (z1 >= insize[0]) z1 = insize[2]-1;

  float fx1 = x - floor(x);
  float fy1 = y - floor(y);
  float fz1 = z - floor(z);

  float fx0 = 1.0 - fx1;
  float fy0 = 1.0 - fy1;
  float fz0 = 1.0 - fz1;

  float pix000 = src[x0*insize[1]*insize[2] + y0*insize[2] + z0];
  float pix001 = src[x0*insize[1]*insize[2] + y0*insize[2] + z1];
  float pix010 = src[x0*insize[1]*insize[2] + y1*insize[2] + z0];
  float pix011 = src[x0*insize[1]*insize[2] + y1*insize[2] + z1];
  float pix100 = src[x1*insize[1]*insize[2] + y0*insize[2] + z0];
  float pix101 = src[x1*insize[1]*insize[2] + y0*insize[2] + z1];
  float pix110 = src[x1*insize[1]*insize[2] + y1*insize[2] + z0];
  float pix111 = src[x1*insize[1]*insize[2] + y1*insize[2] + z1];

  dst[offset] =
    fx0*fy0*fz0*pix000
    + fx0*fy0*fz1*pix001
    + fx0*fy1*fz0*pix010
    + fx0*fy1*fz1*pix011
    + fx1*fy0*fz0*pix100
    + fx1*fy0*fz1*pix101
    + fx1*fy1*fz0*pix110
    + fx1*fy1*fz1*pix111;
}

//
// Identity map
//

__kernel void identity(
  __global float* spacing,
  __global float* hx,
  __global float* hy,
  __global float* hz)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
    return;

  size_t offset = slice*ROWS*COLUMNS + row*COLUMNS + column;

  // TODO: use image spacing and origin
  // orient? assume already axial
  //hx[offset] = slice * spacing[0] + origin[0];
  //hy[offset] = row * spacing[1] + origin[1];
  //hz[offset] = column * spacing[2] + origin[2];

  hx[offset] = slice * spacing[0];
  hy[offset] = row * spacing[1];
  hz[offset] = column * spacing[2];

}

__kernel void identity_resampled(
  __global float* outspacing,
  __global int* outsize,
  __global float* hx,
  __global float* hy,
  __global float* hz)
{
  size_t column = get_global_id(2);
  size_t row = get_global_id(1);
  size_t slice = get_global_id(0);

  //if (slice >= SLICES || row >= ROWS || column >= COLUMNS)
  if (slice >= outsize[0] || row >= outsize[1] || column >= outsize[2])
    return;

  size_t offset = slice*outsize[1]*outsize[2] + row*outsize[2] + column;

  hx[offset] = slice * outspacing[0];
  hy[offset] = row * outspacing[1];
  hz[offset] = column * outspacing[2];
}

// vim: filetype=C
